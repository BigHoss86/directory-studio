/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *  
 *    http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License. 
 *  
 */
package org.apache.directory.studio.schemaeditor.view.wizards;


import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.naming.NamingException;

import org.apache.directory.shared.converter.schema.AttributeTypeHolder;
import org.apache.directory.shared.converter.schema.ObjectClassHolder;
import org.apache.directory.studio.schemaeditor.Activator;
import org.apache.directory.studio.schemaeditor.PluginUtils;
import org.apache.directory.studio.schemaeditor.controller.SchemaHandler;
import org.apache.directory.studio.schemaeditor.model.AttributeTypeImpl;
import org.apache.directory.studio.schemaeditor.model.ObjectClassImpl;
import org.apache.directory.studio.schemaeditor.model.Schema;
import org.apache.directory.studio.schemaeditor.view.ViewUtils;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.wizard.Wizard;
import org.eclipse.ui.IExportWizard;
import org.eclipse.ui.IWorkbench;


/**
 * This class represents the wizard to export schemas for Apache DS.
 *
 * @author <a href="mailto:dev@directory.apache.org">Apache Directory Project</a>
 * @version $Rev$, $Date$
 */
public class ExportSchemasForADSWizard extends Wizard implements IExportWizard
{
    /** The selected schemas */
    private Schema[] selectedSchemas = new Schema[0];

    // The pages of the wizard
    private ExportSchemasForADSWizardPage page;


    /* (non-Javadoc)
     * @see org.eclipse.jface.wizard.Wizard#addPages()
     */
    public void addPages()
    {
        // Creating pages
        page = new ExportSchemasForADSWizardPage();
        page.setSelectedSchemas( selectedSchemas );

        // Adding pages
        addPage( page );
    }


    /* (non-Javadoc)
     * @see org.eclipse.jface.wizard.Wizard#performFinish()
     */
    public boolean performFinish()
    {
        // Saving the dialog settings
        page.saveDialogSettings();

        // Getting the schemas to be exported and where to export them
        final Schema[] selectedSchemas = page.getSelectedSchemas();
        int exportType = page.getExportType();
        if ( exportType == ExportSchemasAsXmlWizardPage.EXPORT_MULTIPLE_FILES )
        {
            final String exportDirectory = page.getExportDirectory();
            try
            {
                getContainer().run( false, true, new IRunnableWithProgress()
                {
                    public void run( IProgressMonitor monitor )
                    {
                        monitor.beginTask( "Exporting schemas: ", selectedSchemas.length );
                        for ( Schema schema : selectedSchemas )
                        {
                            monitor.subTask( schema.getName() );

                            StringBuffer sb = new StringBuffer();
                            DateFormat format = DateFormat.getDateTimeInstance( DateFormat.LONG, DateFormat.MEDIUM );
                            Date date = new Date();
                            sb.append( "# Generated by Apache Directory Studio on " + format.format( date ) + "\n" );
                            sb.append( "\n" );

                            try
                            {
                                toLdif( schema, sb );

                                BufferedWriter buffWriter = new BufferedWriter( new FileWriter( exportDirectory + "/"
                                    + schema.getName() + ".ldif" ) );
                                buffWriter.write( sb.toString() );
                                buffWriter.close();
                            }
                            catch ( IOException e )
                            {
                                PluginUtils.logError( "An error occured when saving the schema " + schema.getName()
                                    + ".", e );
                                ViewUtils.displayErrorMessageBox( "Error", "An error occured when saving the schema "
                                    + schema.getName() + "." );
                            }
                            catch ( NamingException e )
                            {
                                PluginUtils.logError( "An error occured when saving the schema " + schema.getName()
                                    + ".", e );
                                ViewUtils.displayErrorMessageBox( "Error", "An error occured when saving the schema "
                                    + schema.getName() + "." );
                            }
                            monitor.worked( 1 );
                        }
                        monitor.done();
                    }
                } );
            }
            catch ( InvocationTargetException e )
            {
                // Nothing to do (it will never occur)
            }
            catch ( InterruptedException e )
            {
                // Nothing to do.
            }
        }
        else if ( exportType == ExportSchemasAsXmlWizardPage.EXPORT_SINGLE_FILE )
        {
            final String exportFile = page.getExportFile();
            try
            {
                getContainer().run( false, true, new IRunnableWithProgress()
                {
                    public void run( IProgressMonitor monitor )
                    {
                        monitor.beginTask( "Exporting schemas ", 1 );

                        StringBuffer sb = new StringBuffer();
                        DateFormat format = DateFormat.getDateTimeInstance( DateFormat.LONG, DateFormat.MEDIUM );
                        Date date = new Date();
                        sb.append( "# Generated by Apache Directory Studio on " + format.format( date ) + "\n" );
                        sb.append( "\n" );

                        for ( Schema schema : selectedSchemas )
                        {
                            try
                            {
                                toLdif( schema, sb );
                            }
                            catch ( NamingException e )
                            {
                                PluginUtils.logError( "An error occured when saving the schema " + schema.getName()
                                    + ".", e );
                                ViewUtils.displayErrorMessageBox( "Error", "An error occured when saving the schema "
                                    + schema.getName() + "." );
                            }
                        }

                        try
                        {
                            BufferedWriter buffWriter = new BufferedWriter( new FileWriter( exportFile ) );
                            buffWriter.write( sb.toString() );
                            buffWriter.close();
                        }
                        catch ( IOException e )
                        {
                            PluginUtils.logError( "An error occured when saving the schemas.", e );
                            ViewUtils.displayErrorMessageBox( "Error", "An error occured when saving the schemas." );
                        }
                        monitor.worked( 1 );
                        monitor.done();
                    }
                } );
            }
            catch ( InvocationTargetException e )
            {
                // Nothing to do (it will never occur)
            }
            catch ( InterruptedException e )
            {
                // Nothing to do.
            }
        }

        return true;
    }


    /**
     * Converts the given schema as its LDIF for Apache DS representation and stores it into the given StringBuffer.
     *
     * @param schema
     *      the schema
     * @param sb
     *      the StringBuffer
     * @throws NamingException
     *      if an error occurs during the conversion
     */
    private void toLdif( Schema schema, StringBuffer sb ) throws NamingException
    {
        sb.append( "# SCHEMA '" + schema.getName().toUpperCase() + "'\n" );

        sb.append( "dn: cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: metaSchema\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "cn: " + schema.getName() + "\n" );
        String[] schemaDependencies = getSchemaDependencies( schema );
        for ( String schemaName : schemaDependencies )
        {
            sb.append( "m-dependencies: " + schemaName + "\n" );
        }
        sb.append( "\n" );

        // Generation the Attribute Types Node
        sb.append( "dn: ou=attributeTypes, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: attributetypes\n" );
        sb.append( "\n" );

        // Generating LDIF for Attributes Types
        for ( AttributeTypeImpl at : schema.getAttributeTypes() )
        {
            AttributeTypeHolder holder = new AttributeTypeHolder( at.getOid() );
            holder.setCollective( at.isCollective() );
            holder.setDescription( at.getDescription() );
            holder.setEquality( at.getEqualityName() );
            List<String> names = new ArrayList<String>();
            for ( String name : at.getNamesRef() )
            {
                names.add( name );
            }
            holder.setNames( names );
            holder.setNoUserModification( !at.isCanUserModify() );
            holder.setObsolete( at.isObsolete() );
            holder.setOrdering( at.getOrderingName() );
            holder.setSingleValue( at.isSingleValue() );
            holder.setSubstr( at.getSubstrName() );
            holder.setSuperior( at.getSuperiorName() );
            holder.setSyntax( at.getSyntaxOid() );
            holder.setOidLen( at.getLength() );
            holder.setUsage( at.getUsage() );

            sb.append( holder.toLdif( schema.getName() ) + "\n" );
        }

        // Generation the Comparators Node
        sb.append( "dn: ou=comparators, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: comparators\n" );
        sb.append( "\n" );

        // Generation the DIT Content Rules Node
        sb.append( "dn: ou=ditContentRules, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: ditcontentrules\n" );
        sb.append( "\n" );

        // Generation the DIT Structure RulesNode
        sb.append( "dn: ou=ditStructureRules, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: ditstructurerules\n" );
        sb.append( "\n" );

        // Generation the Matching Rules Node
        sb.append( "dn: ou=matchingRules, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: matchingrules\n" );
        sb.append( "\n" );

        // Generation the Matching Rule Use Node
        sb.append( "dn: ou=matchingRuleUse, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: matchingruleuse\n" );
        sb.append( "\n" );

        // Generation the Name Forms Node
        sb.append( "dn: ou=nameForms, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: nameforms\n" );
        sb.append( "\n" );

        // Generation the Normalizers Node
        sb.append( "dn: ou=normalizers, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: normalizers\n" );
        sb.append( "\n" );

        // Generation the Object Classes Node
        sb.append( "dn: ou=objectClasses, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: objectClasses\n" );
        sb.append( "\n" );

        // Generating LDIF for Object Classes
        for ( ObjectClassImpl oc : schema.getObjectClasses() )
        {
            ObjectClassHolder holder = new ObjectClassHolder( oc.getOid() );
            holder.setClassType( oc.getType() );
            holder.setDescription( oc.getDescription() );
            List<String> mayList = new ArrayList<String>();
            for ( String may : oc.getMayNamesList() )
            {
                mayList.add( may );
            }
            holder.setMay( mayList );
            List<String> mustList = new ArrayList<String>();
            for ( String must : oc.getMustNamesList() )
            {
                mustList.add( must );
            }
            holder.setMust( mustList );
            List<String> names = new ArrayList<String>();
            for ( String name : oc.getNamesRef() )
            {
                names.add( name );
            }
            holder.setNames( names );
            List<String> superiorList = new ArrayList<String>();
            for ( String superior : oc.getSuperClassesNames() )
            {
                superiorList.add( superior );
            }
            holder.setSuperiors( superiorList );
            holder.setObsolete( oc.isObsolete() );

            sb.append( holder.toLdif( schema.getName() ) + "\n" );
        }

        // Generation the Syntax Checkers Node
        sb.append( "dn: ou=syntaxCheckers, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: syntaxcheckers\n" );
        sb.append( "\n" );

        // Generation the Syntaxes Node
        sb.append( "dn: ou=syntaxes, cn=" + schema.getName() + ", ou=schema\n" );
        sb.append( "objectclass: organizationalUnit\n" );
        sb.append( "objectclass: top\n" );
        sb.append( "ou: syntaxes\n" );
        sb.append( "\n" );
    }


    /**
     * Gets the schema dependencies.
     *
     * @param schema
     *      the schema
     * @return
     *      an array containing the names of all the schemas which the given
     *      schema depends on
     */
    private String[] getSchemaDependencies( Schema schema )
    {
        Set<String> schemaNames = new HashSet<String>();
        SchemaHandler schemaHandler = Activator.getDefault().getSchemaHandler();

        // Looping on Attribute Types
        for ( AttributeTypeImpl at : schema.getAttributeTypes() )
        {
            // Superior
            String supName = at.getSuperiorName();
            if ( supName != null )
            {
                AttributeTypeImpl sup = schemaHandler.getAttributeType( supName );
                if ( sup != null )
                {
                    if ( !schema.getName().toLowerCase().equals( sup.getSchema().toLowerCase() ) )
                    {
                        schemaNames.add( sup.getSchema() );
                    }
                }
            }
        }

        // Looping on Object Classes
        for ( ObjectClassImpl oc : schema.getObjectClasses() )
        {
            // Superiors
            String[] supNames = oc.getSuperClassesNames();
            if ( supNames != null )
            {
                for ( String supName : oc.getSuperClassesNames() )
                {
                    ObjectClassImpl sup = schemaHandler.getObjectClass( supName );
                    if ( sup != null )
                    {
                        if ( !schema.getName().toLowerCase().equals( sup.getSchema().toLowerCase() ) )
                        {
                            schemaNames.add( sup.getSchema() );
                        }
                    }
                }
            }

            // Mays
            String[] mayNames = oc.getMayNamesList();
            if ( mayNames != null )
            {
                for ( String mayName : mayNames )
                {
                    AttributeTypeImpl may = schemaHandler.getAttributeType( mayName );
                    if ( may != null )
                    {
                        if ( !schema.getName().toLowerCase().equals( may.getSchema().toLowerCase() ) )
                        {
                            schemaNames.add( may.getSchema() );
                        }
                    }
                }

            }

            // Musts
            String[] mustNames = oc.getMustNamesList();
            if ( mustNames != null )
            {
                for ( String mustName : oc.getMustNamesList() )
                {
                    AttributeTypeImpl must = schemaHandler.getAttributeType( mustName );
                    if ( must != null )
                    {
                        if ( !schema.getName().toLowerCase().equals( must.getSchema().toLowerCase() ) )
                        {
                            schemaNames.add( must.getSchema() );
                        }
                    }
                }
            }
        }

        return schemaNames.toArray( new String[0] );
    }


    /* (non-Javadoc)
     * @see org.eclipse.ui.IWorkbenchWizard#init(org.eclipse.ui.IWorkbench, org.eclipse.jface.viewers.IStructuredSelection)
     */
    public void init( IWorkbench workbench, IStructuredSelection selection )
    {
        setNeedsProgressMonitor( true );
    }


    /**
     * Sets the selected projects.
     *
     * @param schemas
     *      the schemas
     */
    public void setSelectedSchemas( Schema[] schemas )
    {
        selectedSchemas = schemas;
    }
}
